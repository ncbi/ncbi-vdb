/*=====================================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
* ================================================================================== */

#include <kns/extern.h>

#include <kfs/directory.h> /* KDirectoryRelease */

#include <klib/printf.h> /* string_printf */
#include <klib/rc.h> /* RC */
#include <klib/text.h> /* string_measure */

#include <kns/cloud.h> /* KNSManagerMakeAwsAuthenticationHeader */
#include <kns/http.h> /* KClientHttpRequestRelease */
#include <kns/stream.h> /* KStreamRelease */

#include <ext/mbedtls/base64.h> /* vdb_mbedtls_base64_encode */
#include <ext/mbedtls/md.h> /* mbedtls_md_context_t */

#include "mgr-priv.h" /* KNSManagerSetLogNcbiVdbNetError */
#include "cloud.h" /* KNSManagerMakeCloud */

/* compare HMAC_SHA1 generated by Digest::HMAC_SHA1 and vdb_mbedtls_md_hmac;
turn on debugging messages
#define DEBUGGING 1 */

#if DEBUGGING
#include <stdio.h> /* popen */
#endif

#define RELEASE(type, obj) do { rc_t rc2 = type##Release(obj); \
    if (rc2 != 0 && rc == 0) { rc = rc2; } obj = NULL; } while (false)

typedef struct Cloud {
    char * location;
} Cloud;

static bool _KDirectory_FileExists(const KDirectory * self,
    const char * path)
{
    return KDirectoryPathType_v1(self, path) != kptNotFound;
}

rc_t CloudRelease(const Cloud * cself) {
    Cloud * self = (Cloud*)cself;

    if (self != NULL) {
        free(self->location);

        memset(self, 0, sizeof * self);

        free(self);
    }

    return 0;
}

static rc_t CloudMakeEmpty(Cloud ** self) {
    *self = calloc(1, sizeof **self);

    if (*self == NULL)
        return RC(rcNS, rcStorage, rcAllocating, rcMemory, rcExhausted);
    else
        return 0;
}

static rc_t CloudMake(const Cloud ** self,
    bool gs, const char * zone, size_t zsize)
{
    size_t size = 2 + 1 + zsize;

    const char* slash = NULL;

    Cloud * p = NULL;

    rc_t rc = CloudMakeEmpty(&p);
    if (rc != 0)
        return rc;

    slash = string_rchr(zone, zsize, '/');
    if (slash != NULL && slash - zone < zsize) {
        size -= slash - zone + 1;
        zone = slash + 1;
    }

    p->location = calloc(1, size);
    if (p->location == NULL)
        rc = RC(rcNS, rcStorage, rcAllocating, rcMemory, rcExhausted);

    if (rc == 0)
        rc = string_printf(p->location, size, NULL,
            "%s.%s", gs ? "gs" : "s3", zone);

    assert(self);
    if (rc == 0)
        *self = p;
    else
        CloudRelease(p);

    return rc;
}

#define GS "http://metadata.google.internal/computeMetadata/v1/instance/zone"
#define S3 "http://169.254.169.254/latest/meta-data/placement/availability-zone"

static rc_t _KNSManager_Read(struct KNSManager * self,
    bool gs, const Cloud ** cloud)
{
    rc_t rc = 0;

    const char * url = gs ? GS : S3;

    KClientHttpRequest *req = NULL;

    /* save existing timeouts */
    int32_t cmsec = self->conn_timeout;
    int32_t wmsec = self->http_write_timeout;

    int32_t timeout = 1; /* milliseconds */

    /* minimize timeouts to check cloudy URLs */
    self->conn_timeout = self->http_write_timeout = timeout;

    rc = KNSManagerMakeClientRequest(self, &req, 0x01010000, NULL, url);

    if (rc == 0) {
        if (gs)
            rc = KClientHttpRequestAddHeader(req, "Metadata-Flavor", "Google");

        if (rc == 0) {
            KClientHttpResult * rslt = NULL;
            rc = KClientHttpRequestGET(req, &rslt);

            /* restore timeouts in KNSManager; may be not needed here */
            self->conn_timeout = cmsec;
            self->http_write_timeout=wmsec;

            if (rc == 0) {
                KStream * s = NULL;
                rc = KClientHttpResultGetInputStream(rslt, &s);
                if (rc == 0) {
                    char buffer[99] = "";
                    size_t num_read = 0;
                    rc = KStreamRead(s, buffer, sizeof buffer, &num_read);
                    if (rc == 0) {
                        if (num_read == sizeof buffer)
                            --num_read;
                        buffer[num_read++] = '\0';

                        if (rc == 0)
                            rc = CloudMake(cloud, gs, buffer, num_read);
                    }
                }
                RELEASE(KStream, s);
            }
            RELEASE(KClientHttpResult, rslt);
        }
    }

    RELEASE(KClientHttpRequest, req);

    /* restore timeouts in KNSManager */
    self->conn_timeout = cmsec;
    self->http_write_timeout = wmsec;

    return rc;
}

rc_t KNSManagerMakeCloud(struct KNSManager * self,
    const Cloud ** cloud)
{
    KDirectory * dir = NULL;

    rc_t rc = KDirectoryNativeDir(&dir);
    if (rc == 0) {
        bool gcsFirst = true;

        bool log = KNSManagerLogNcbiVdbNetError(self);

        if (_KDirectory_FileExists(dir, "/usr/bin/gcloud"))
            gcsFirst = true;
        else if (_KDirectory_FileExists(dir, "/usr/bin/ec2-metadata"))
            gcsFirst = false;

        if (log)
            KNSManagerSetLogNcbiVdbNetError(self, false);

        rc = _KNSManager_Read(self, gcsFirst, cloud);

        if (rc != 0)
            rc = _KNSManager_Read(self, !gcsFirst, cloud);

        if (rc != 0)
            rc = CloudMakeEmpty((Cloud **)cloud);

        if (log)
            KNSManagerSetLogNcbiVdbNetError(self, true);
    }

    RELEASE(KDirectory, dir);

    return rc;
}

const char * CloudGetLocation(const struct Cloud * self) {
    if (self != NULL)
        return self->location;
    else
        return NULL;
}

/*************************************************************************************/

/* https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html
#ConstructingTheAuthenticationHeader */

#if DEBUGGING
static unsigned char2byte(char c) {
    return c <= '9' ? c - '0' : c - 'a' + 10;
}

static rc_t pHMAC_SHA1(
    const char * YourSecretAccessKeyID,
    const char * StringToSign,
    unsigned char *dst, size_t dsize, size_t *olen)
{
    size_t i = 0;
    char bytes[64] = "";

    FILE * fp = NULL;

    char cmd[4096] = "";
    rc_t rc = string_printf(cmd, sizeof cmd, NULL,
        "perl -e 'use Digest::HMAC_SHA1 qw(hmac_sha1 hmac_sha1_hex);"
        "$data=\"%s\"; $key=\"%s\"; $digest = hmac_sha1($data, $key); "
        "print hmac_sha1_hex($data, $key)'", StringToSign, YourSecretAccessKeyID);
    if (rc != 0)
        return rc;

#if DEBUGGING
    puts(cmd);
#endif

    fp = popen(cmd, "r");
    if (fp == NULL)
        return 1;
    if (fgets(bytes, sizeof bytes - 1, fp) == NULL)
        rc = 2;
    pclose(fp);

#if DEBUGGING
    printf("as str: %s\n", bytes);
#endif

    assert(olen);
    *olen = 0;
    for (i = 0; ; i += 2) {
        if (bytes[i] == '\0')
            break;
        assert(bytes[i] && bytes[i + 1]);
        dst[(*olen)++] = (char2byte(bytes[i]) << 4) + char2byte(bytes[i + 1]);
    }

#if DEBUGGING
    printf("as hex: ");
    for (i = 0; i < *olen; ++i)
        printf("%x", dst[i]);
    puts("");
#endif

    return rc;
}
#endif

/* use mbedtls to generate HMAC_SHA1 */
static rc_t HMAC_SHA1(
    const char *key,
    const char *input,
    unsigned char *output)
{
    int ret = 0;

    const mbedtls_md_info_t *md_info = vdb_mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);

    size_t keylen = string_measure(key, NULL);
    size_t ilen = string_measure(input, NULL);

    ret = vdb_mbedtls_md_hmac(md_info, (unsigned char *)key, keylen,
        (unsigned char *)input, ilen, output);

    return ret == 0 ? 0 : RC(rcVFS, rcUri, rcInitializing, rcEncryption, rcFailed);
}

/* Encode a buffer into base64 format */
static rc_t Base64(
    const unsigned char *src, size_t slen,
    char *dst, size_t dlen)
{
    rc_t rc = 0;

    size_t olen = 0;

#if DEBUGGING
    puts("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv");
    printf("SRC   : ");
    size_t i = 0;
    for (i = 0; i < slen; ++i)
        printf("%x", src[i]);
    puts("");
#endif

    if (vdb_mbedtls_base64_encode((unsigned char *)dst, dlen, &olen, src, slen) != 0)
        rc = RC(rcVFS, rcUri, rcEncoding, rcString, rcInsufficient);

#if DEBUGGING
    olen = strlen((char*)dst);
    printf("DST   : ");
    for (i = 0; i < olen; ++i)
        printf("%c", dst[i]);
    puts("");
    printf("base64: %s\n", dst);
    puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
#endif

    return rc;
}

/* Compute AWS authenticating Signature:
Signature
= Base64( HMAC-SHA1( YourSecretAccessKeyID, UTF-8-Encoding-Of( StringToSign ) ) ); */
static rc_t Signature(const char * YourSecretAccessKeyID,
    const char * StringToSign,
    char *dst, size_t dlen)
{
    unsigned char src[64] = "";

#if DEBUGGING
    int i = 0;
    unsigned char pbuf[64] = "";
#endif

    size_t slen = 20;
    rc_t rc = HMAC_SHA1(YourSecretAccessKeyID, StringToSign, src);

#if DEBUGGING
    rc_t r = pHMAC_SHA1(YourSecretAccessKeyID, StringToSign, pbuf, sizeof pbuf, &slen);

    assert(rc == r);
    assert(slen == 20);
    for (i = 0; i < slen; ++i) {
        assert(src[i] == pbuf[i]);
    }
#endif

    if (rc == 0)
        rc = Base64(src, slen, dst, dlen);

    return rc;
}

/* MakeAwsAuthenticationHeader
*  constructs the Authorization request header value
*  ( https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html )
*
*  AWSAccessKeyId [ IN ] - AWS access key ID
*  YourSecretAccessKeyID [ IN ] - AWS secret access key
*  StringToSign [ IN ] - String To Sign
*  dst [ OUT ] - destination buffer, NULL-terminated
*  dlen [ IN ] - size of the destination buffer
*/
LIB_EXPORT rc_t CC KNSManagerMakeAwsAuthenticationHeader(
    const struct KNSManager *self,
    const char *AWSAccessKeyId,
    const char *YourSecretAccessKeyID,
    const char *StringToSign,
    char *dst, size_t dlen)
{
    size_t num_writ = 0;

    rc_t rc = string_printf(dst, dlen, &num_writ, "AWS %s:", AWSAccessKeyId);

    if (rc == 0) {
        if (num_writ >= dlen)
            return RC(rcVFS, rcUri, rcIdentifying, rcString, rcInsufficient);

        rc = Signature(YourSecretAccessKeyID, StringToSign,
            dst + num_writ, dlen - num_writ);
    }

    return rc;
}

/*************************************************************************************/
